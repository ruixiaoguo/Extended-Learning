
# 线程安全性代表了并发程序的正确性，指的是在多线程环境下，应用程序始终能够表现出正确的行为。

- 所有的线程安全性问题，都可以归结于同一个原因: 共享的可变状态。
  - 原子性
  - 可见性
  - 有序性


## 注意

- 避免共享状态
    - 使用栈封闭，函数内临时变量
    - 使用 TreadLocal


- 避免可变性


- 使用同步锁
    这可能导致降低线程活跃性


# 线程活跃性代表了并发程序的执行效率，指的是引入多线程后，比原来的单线程程序降低了多少执行时间。

- 线程开销。
- 阻塞。
- 死锁。
- 活锁。



## 注意

- 避免使用锁，改为避免可变状态、避免共享状态等手段
- 降低锁的粒度
- 加上超时限制


# 工具

- Jstack。通过jstack命令，获取线程执行信息，找出其中的线程阻塞和死锁问题。
- Heap dump。通过jmap命令dump出当前的jvm 堆栈信息，然后使用内存分析工具识别线程阻塞和死锁。
- Arthas。作为阿里开源的Java诊断利器，arthas也提供了线程分析诊断功能, 可以通过arthas的thread命令，查找出当前阻塞的线程。

# 并发类库

- Executor
- Atomic 5.0
- Lock
- ConcurrentHashMap
- Semaphore