# GPU呈现模式分析

# 1. 工具
Android Studio 2.3 中包含了Android Monitor工具，其中一项为GPU Monitor工具。相对于设备上的柱状GPU呈现模式分析，这个工具提供了更好的可视化特性。  

![](https://gw.alicdn.com/tfs/TB1H_R6cBfH8KJjy1XbXXbLdXXa-1932-1242.png)

# 2. 数据指标说明

## 2.1 柱状图构成
柱状图依次由以下几个阶段的耗时构成。  

![](https://gw.alicdn.com/tfs/TB1nH6mX5qAXuNjy1XdXXaYcVXa-730-27.png)   

- 绿线：表示完整的处理一帧消耗时间约为16.6ms，即能达到60FPS。低于这个值是最理想的状态，视图会很流畅。  

- 红线：表示完整的处理一帧消耗时间约为16.6ms，即能达到30FPS。如果高于这个值，就能感觉出明显的卡顿。

## 2.2 各阶段说明

### 2.2.1 Misc(Miscellaneous)

与渲染无关的耗时。表示执行在主线程的，并且与渲染无关的其它事务的所消耗的时间。通常，该项数据能够表明主线程上在连续两帧之间发生的工作的耗时。

如果这个值很高，表明你的主线程上与UI无关的事务太多了，拖慢了UI渲染效率。通常需要找到耗时的操作，将这些操作移到子线程中。可以通过代码分析或者借助【Systrace工具】来分析主线程上的耗时操作。

### 2.2.2 Input(Input Handling)
输入事件处理耗时。该项通常表示在接收输入事件后，执行该事件回调代码的耗时。  

如果这个值很高，表明你在输入事件回调中处理了太多的工作。输入事件的回调默认是在主线程的，因该把这些耗时操作放到子线程中执行。这个问题在滚动列表控件中尤为突出。列表控件在处理输入事件时会立即发生滚动，滚动操作本身就是相对耗时的，如果在列表中添加、移除、更新子视图的操作过于臃肿，很容易就推高了这个阶段的耗时。

### 2.2.3 Anim(Animation)
执行动画耗时。表明在一帧之中，计算所有动画所需数值的耗时。  

如果这个值很高，表明该帧中，由于动画改变了某个视图的属性，从而需要经过一系列计算来确定视图的下一个状态所消耗的时间过多。比如，列表控件在惯性滚动时，就会发生相对复杂的计算来确定新的视图状态。

### 2.2.4 Measure(Measurement/Layout)
测量和布局耗时。表明视图树发生遍历测量和计算确定每个子视图的位置的过程所消耗的时间。  

如果这个值很高，表明你的视图树出了问题。可能是过于复杂，层级过深，也可能是某个自定义ViewGroup中的`onMeasure()`或者`onLayout()`的代码效率过低。  

### 2.2.5 Draw(Drawing)
绘制耗时。表明视图树在一帧中，所有需要绘制的元素的绘制耗时之和。比如View的`onDraw()`，Drawable的`draw()`等过程。  

如果这个值很高，表明可能你的`onDraw()`方法中存在太多的工作需要处理，或者很多不需要更新的视图重复执行了`onDraw()`。

### 2.2.6 Upload(Sync/Upload) 
用于绘制的内存块的同步和上传耗时。通常在CPU绘制完一块内存后，需要将它传输到GPU内存中才能被硬件取出，渲染到屏幕上。这个数值表示了该过程的耗时。  

如果这个值很高，表示可能你在这一帧中有较大内存的视图需要上传到GPU中。如何优化这个过程呢？  
 
1. Bitmap的实际不要超过它所需要显示的大小。可以在显示前先将Bitmap压缩到适合的大小。
2. 可以通过`Bitmap#prepareToDraw()`异步的将Bitmap先上传到GPU中，以被后面显示使用。这样能够缩短Upload耗时。


### 2.2.7 Issue(Issuing Commands)
发出显示命令耗时。视图绘制列表在被显示到屏幕之前，系统需要发出一系列的命令让硬件将绘制列表绘制到屏幕上。系统计算产生这些绘制命令需要消耗一些时间。  

如果这个值很高，表明你的draw的东西太多了。比如:   

```
for (int i = 0; i < 1000; i++){
	canvas.drawPoint()
}
```
比  

```
canvas.drawPoints(mThousandPointArray);
```
需要发出的命令更多，因此该项的耗时也会跟多。  

此外，该项的值很高并不意味着Draw过程也会很高。因为命令会受到优化和裁剪，一些系统判定为不需要重复绘制的命令并不会被重复的计算，而是直接使用缓存命令。所以，在写`onDraw()`的时候需要时刻谨慎的对待每一个`canvas.darwXXX()`操作。

### 2.2.8 Swap(Processing/Swapping Buffers)
当CPU和GPU通信队列慢了之后，CPU会被阻塞，直到GPU消耗队列中的绘制命令，从而让队列中出现空位，CPU才能继续向GPU中发送命令。该值表示在这个过程中，CPU等待的时间。  

如果这个值很高，表示GPU的工作过重，导致GPU消耗命令的速度比CPU发送命令的速度慢。这个问题通常和`Issuing Commands`是正相关的。


